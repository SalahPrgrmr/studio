/**
 * @fileoverview Firestore Security Rules for the Eye of Certainty application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data and
 * utilizes denormalized member lists for shared resources like live streams and voice chat rooms.
 * Public read access is granted selectively to collections like certainty definitions.
 * A moderation system is in place for user-generated content like success stories,
 * ensuring it is reviewed and approved by an admin before becoming public.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the user themselves.
 * - /community_forum_posts/{postId}: Stores forum posts, with owner-only writes.
 * - /success_stories/{storyId}: Stores success stories. Users can create stories with a 'pending_review' status.
 *   Only admins can change the status to 'approved', and only approved stories are publicly visible.
 * - /certainty_definitions/{definitionId}: Stores public definitions, writeable only by admins.
 * - /live_streams/{streamId}: Stores live stream data, secured by a denormalized 'members' map.
 * - /voice_chat_rooms/{roomId}: Stores voice chat room data, secured by a denormalized 'members' map.
 * - /voice_chat_rooms/{roomId}/messages/{messageId}: Stores voice chat messages, also secured by a denormalized 'members' map from the parent room.
 * - /video_chat_rooms/{roomId}: Stores video chat room data.
 * - /roles_admin/{uid}: Used for Database-Based Access Control (DBAC) to grant admin privileges.
 *
 * Key Security Decisions:
 * - User listing is implicitly denied (no `allow list: if true` on /users).
 * - Read-only collections like certainty definitions are explicitly marked as such.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 * - The `members` map is denormalized to avoid costly `get()` calls.
 * - A 'status' field ('pending_review', 'approved') on user content enables a moderation workflow.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    match /users/{userId} {
      function isOwner() {
        return request.auth.uid == userId;
      }
      allow read, write: if isSignedIn() && isOwner();
      allow list: if false;
    }

    match /community_forum_posts/{postId} {
        function isOwner() {
          return request.auth.uid == resource.data.authorId;
        }

        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow get, list: if true;
        allow update, delete: if isSignedIn() && isOwner();
    }

    /**
     * @description Controls access to success stories with a moderation system.
     * @path /success_stories/{storyId}
     * @allow (create) Signed-in user creates a story, forced to 'pending_review' status.
     *     request.resource.data.status == 'pending_review'
     * @allow (list) Any user can list stories, but only those marked as 'approved'.
     *     resource.data.status == 'approved'
     * @allow (update) Only admins can update stories (e.g., to approve them).
     *     isAdmin()
     * @deny (delete) Deletes are disallowed for now to preserve history.
     */
    match /success_stories/{storyId} {
        function isOwner() {
          return request.auth.uid == resource.data.authorId;
        }

        // Anyone can read a story that has been approved.
        allow get: if resource.data.status == 'approved';
        
        // Anyone can list the collection, but the query must filter for `status == 'approved'`.
        // The rule itself doesn't filter, it only enforces that any document read
        // during a list operation must meet this condition.
        allow list: if true;

        // Any signed-in user can create a story, but they MUST set the status to 'pending_review'.
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid
                         && request.resource.data.status == 'pending_review';

        // Only an admin can update a story (e.g., to change status to 'approved').
        // The owner cannot edit their story after submission.
        allow update: if isAdmin();
        
        // Only admins can delete stories.
        allow delete: if isAdmin();
    }


    match /certainty_definitions/{definitionId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    match /live_streams/{streamId} {
      allow create: if isSignedIn();
      allow get, list: if isSignedIn() && resource.data.members[request.auth.uid] != null;
      allow update: if isSignedIn() && resource.data.members[request.auth.uid] != null && resource != null;
      allow delete: if isSignedIn() && resource.data.members[request.auth.uid] != null && resource != null;
    }

     match /voice_chat_rooms/{roomId} {
        function isOwner() {
          return request.auth.uid == request.resource.data.ownerId;
        }
        function isExistingOwner() {
          return request.auth.uid == resource.data.ownerId;
        }

        allow create: if isSignedIn() && isOwner();
        allow get, list: if true;
        allow update: if isSignedIn() && isExistingOwner();
        allow delete: if isSignedIn() && isExistingOwner();
    }
    
     match /video_chat_rooms/{roomId} {
        function isOwner() {
          return request.auth.uid == request.resource.data.ownerId;
        }
        function isExistingOwner() {
          return request.auth.uid == resource.data.ownerId;
        }

        allow create: if isSignedIn() && isOwner();
        allow get, list: if true;
        allow update: if isSignedIn() && isExistingOwner();
        allow delete: if isSignedIn() && isExistingOwner();
    }

    match /voice_chat_rooms/{roomId}/messages/{messageId} {
        function isRoomMember(roomId) {
            return get(/databases/$(database)/documents/voice_chat_rooms/$(roomId)).data.members[request.auth.uid] != null;
        }
        
        allow create: if isSignedIn() && isRoomMember(roomId);
        allow get, list: if isSignedIn() && isRoomMember(roomId);
        allow update: if false;
        allow delete: if false;
    }

    match /roles_admin/{uid} {
      allow read, write: if isAdmin();
    }
  }
}
